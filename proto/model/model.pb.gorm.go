// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/model/model.proto

/*
Package model is a generated protocol buffer package.

It is generated from these files:
	proto/model/model.proto

It has these top-level messages:
	Currency
	RateOfExchange
	Location
	Product
	Price
	Position
	Employee
	Method
	Receipt
	Purchase
*/
package model

import context "context"

import errors1 "github.com/infobloxopen/protoc-gen-gorm/errors"
import field_mask1 "google.golang.org/genproto/protobuf/field_mask"
import gorm1 "github.com/jinzhu/gorm"
import gorm2 "github.com/infobloxopen/atlas-app-toolkit/gorm"

import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = math.Inf

type CurrencyORM struct {
	Code string
	Id   uint32
	Name string
}

// TableName overrides the default tablename generated by GORM
func (CurrencyORM) TableName() string {
	return "currency"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Currency) ToORM(ctx context.Context) (CurrencyORM, error) {
	to := CurrencyORM{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if posthook, ok := interface{}(m).(CurrencyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *CurrencyORM) ToPB(ctx context.Context) (Currency, error) {
	to := Currency{}
	var err error
	if prehook, ok := interface{}(m).(CurrencyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Code = m.Code
	if posthook, ok := interface{}(m).(CurrencyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Currency the arg will be the target, the caller the one being converted from

// CurrencyBeforeToORM called before default ToORM code
type CurrencyWithBeforeToORM interface {
	BeforeToORM(context.Context, *CurrencyORM) error
}

// CurrencyAfterToORM called after default ToORM code
type CurrencyWithAfterToORM interface {
	AfterToORM(context.Context, *CurrencyORM) error
}

// CurrencyBeforeToPB called before default ToPB code
type CurrencyWithBeforeToPB interface {
	BeforeToPB(context.Context, *Currency) error
}

// CurrencyAfterToPB called after default ToPB code
type CurrencyWithAfterToPB interface {
	AfterToPB(context.Context, *Currency) error
}

type RateOfExchangeORM struct {
	FromId uint32
	Id     uint32
	Price  float32
	ToId   uint32
}

// TableName overrides the default tablename generated by GORM
func (RateOfExchangeORM) TableName() string {
	return "rates_of_exchange"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *RateOfExchange) ToORM(ctx context.Context) (RateOfExchangeORM, error) {
	to := RateOfExchangeORM{}
	var err error
	if prehook, ok := interface{}(m).(RateOfExchangeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FromId = m.FromId
	to.ToId = m.ToId
	to.Price = m.Price
	if posthook, ok := interface{}(m).(RateOfExchangeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *RateOfExchangeORM) ToPB(ctx context.Context) (RateOfExchange, error) {
	to := RateOfExchange{}
	var err error
	if prehook, ok := interface{}(m).(RateOfExchangeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FromId = m.FromId
	to.ToId = m.ToId
	to.Price = m.Price
	if posthook, ok := interface{}(m).(RateOfExchangeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type RateOfExchange the arg will be the target, the caller the one being converted from

// RateOfExchangeBeforeToORM called before default ToORM code
type RateOfExchangeWithBeforeToORM interface {
	BeforeToORM(context.Context, *RateOfExchangeORM) error
}

// RateOfExchangeAfterToORM called after default ToORM code
type RateOfExchangeWithAfterToORM interface {
	AfterToORM(context.Context, *RateOfExchangeORM) error
}

// RateOfExchangeBeforeToPB called before default ToPB code
type RateOfExchangeWithBeforeToPB interface {
	BeforeToPB(context.Context, *RateOfExchange) error
}

// RateOfExchangeAfterToPB called after default ToPB code
type RateOfExchangeWithAfterToPB interface {
	AfterToPB(context.Context, *RateOfExchange) error
}

type LocationORM struct {
	CurrencyId  uint32
	Description string
	Id          uint32
	Name        string
	Status      bool
}

// TableName overrides the default tablename generated by GORM
func (LocationORM) TableName() string {
	return "locations"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Location) ToORM(ctx context.Context) (LocationORM, error) {
	to := LocationORM{}
	var err error
	if prehook, ok := interface{}(m).(LocationWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.CurrencyId = m.CurrencyId
	to.Status = m.Status
	if posthook, ok := interface{}(m).(LocationWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LocationORM) ToPB(ctx context.Context) (Location, error) {
	to := Location{}
	var err error
	if prehook, ok := interface{}(m).(LocationWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	to.CurrencyId = m.CurrencyId
	to.Status = m.Status
	if posthook, ok := interface{}(m).(LocationWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Location the arg will be the target, the caller the one being converted from

// LocationBeforeToORM called before default ToORM code
type LocationWithBeforeToORM interface {
	BeforeToORM(context.Context, *LocationORM) error
}

// LocationAfterToORM called after default ToORM code
type LocationWithAfterToORM interface {
	AfterToORM(context.Context, *LocationORM) error
}

// LocationBeforeToPB called before default ToPB code
type LocationWithBeforeToPB interface {
	BeforeToPB(context.Context, *Location) error
}

// LocationAfterToPB called after default ToPB code
type LocationWithAfterToPB interface {
	AfterToPB(context.Context, *Location) error
}

type ProductORM struct {
	Description string
	Id          uint32
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (ProductORM) TableName() string {
	return "products"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Product) ToORM(ctx context.Context) (ProductORM, error) {
	to := ProductORM{}
	var err error
	if prehook, ok := interface{}(m).(ProductWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(ProductWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ProductORM) ToPB(ctx context.Context) (Product, error) {
	to := Product{}
	var err error
	if prehook, ok := interface{}(m).(ProductWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(ProductWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Product the arg will be the target, the caller the one being converted from

// ProductBeforeToORM called before default ToORM code
type ProductWithBeforeToORM interface {
	BeforeToORM(context.Context, *ProductORM) error
}

// ProductAfterToORM called after default ToORM code
type ProductWithAfterToORM interface {
	AfterToORM(context.Context, *ProductORM) error
}

// ProductBeforeToPB called before default ToPB code
type ProductWithBeforeToPB interface {
	BeforeToPB(context.Context, *Product) error
}

// ProductAfterToPB called after default ToPB code
type ProductWithAfterToPB interface {
	AfterToPB(context.Context, *Product) error
}

type PriceORM struct {
	Id         uint32
	LocationId uint32
	Price      float32
	ProductId  uint32
}

// TableName overrides the default tablename generated by GORM
func (PriceORM) TableName() string {
	return "prices"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Price) ToORM(ctx context.Context) (PriceORM, error) {
	to := PriceORM{}
	var err error
	if prehook, ok := interface{}(m).(PriceWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProductId = m.ProductId
	to.LocationId = m.LocationId
	to.Price = m.Price
	if posthook, ok := interface{}(m).(PriceWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PriceORM) ToPB(ctx context.Context) (Price, error) {
	to := Price{}
	var err error
	if prehook, ok := interface{}(m).(PriceWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ProductId = m.ProductId
	to.LocationId = m.LocationId
	to.Price = m.Price
	if posthook, ok := interface{}(m).(PriceWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Price the arg will be the target, the caller the one being converted from

// PriceBeforeToORM called before default ToORM code
type PriceWithBeforeToORM interface {
	BeforeToORM(context.Context, *PriceORM) error
}

// PriceAfterToORM called after default ToORM code
type PriceWithAfterToORM interface {
	AfterToORM(context.Context, *PriceORM) error
}

// PriceBeforeToPB called before default ToPB code
type PriceWithBeforeToPB interface {
	BeforeToPB(context.Context, *Price) error
}

// PriceAfterToPB called after default ToPB code
type PriceWithAfterToPB interface {
	AfterToPB(context.Context, *Price) error
}

type PositionORM struct {
	Description string
	Id          uint32
	Name        string
}

// TableName overrides the default tablename generated by GORM
func (PositionORM) TableName() string {
	return "positions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Position) ToORM(ctx context.Context) (PositionORM, error) {
	to := PositionORM{}
	var err error
	if prehook, ok := interface{}(m).(PositionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(PositionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PositionORM) ToPB(ctx context.Context) (Position, error) {
	to := Position{}
	var err error
	if prehook, ok := interface{}(m).(PositionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	to.Description = m.Description
	if posthook, ok := interface{}(m).(PositionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Position the arg will be the target, the caller the one being converted from

// PositionBeforeToORM called before default ToORM code
type PositionWithBeforeToORM interface {
	BeforeToORM(context.Context, *PositionORM) error
}

// PositionAfterToORM called after default ToORM code
type PositionWithAfterToORM interface {
	AfterToORM(context.Context, *PositionORM) error
}

// PositionBeforeToPB called before default ToPB code
type PositionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Position) error
}

// PositionAfterToPB called after default ToPB code
type PositionWithAfterToPB interface {
	AfterToPB(context.Context, *Position) error
}

type EmployeeORM struct {
	FirstName  string
	Id         uint32
	LastName   string
	LocationId uint32
	PositionId uint32
}

// TableName overrides the default tablename generated by GORM
func (EmployeeORM) TableName() string {
	return "employees"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Employee) ToORM(ctx context.Context) (EmployeeORM, error) {
	to := EmployeeORM{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.PositionId = m.PositionId
	to.LocationId = m.LocationId
	if posthook, ok := interface{}(m).(EmployeeWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *EmployeeORM) ToPB(ctx context.Context) (Employee, error) {
	to := Employee{}
	var err error
	if prehook, ok := interface{}(m).(EmployeeWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.PositionId = m.PositionId
	to.LocationId = m.LocationId
	if posthook, ok := interface{}(m).(EmployeeWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Employee the arg will be the target, the caller the one being converted from

// EmployeeBeforeToORM called before default ToORM code
type EmployeeWithBeforeToORM interface {
	BeforeToORM(context.Context, *EmployeeORM) error
}

// EmployeeAfterToORM called after default ToORM code
type EmployeeWithAfterToORM interface {
	AfterToORM(context.Context, *EmployeeORM) error
}

// EmployeeBeforeToPB called before default ToPB code
type EmployeeWithBeforeToPB interface {
	BeforeToPB(context.Context, *Employee) error
}

// EmployeeAfterToPB called after default ToPB code
type EmployeeWithAfterToPB interface {
	AfterToPB(context.Context, *Employee) error
}

type MethodORM struct {
	Id   uint32
	Name string
}

// TableName overrides the default tablename generated by GORM
func (MethodORM) TableName() string {
	return "methods"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Method) ToORM(ctx context.Context) (MethodORM, error) {
	to := MethodORM{}
	var err error
	if prehook, ok := interface{}(m).(MethodWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if posthook, ok := interface{}(m).(MethodWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MethodORM) ToPB(ctx context.Context) (Method, error) {
	to := Method{}
	var err error
	if prehook, ok := interface{}(m).(MethodWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Name = m.Name
	if posthook, ok := interface{}(m).(MethodWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Method the arg will be the target, the caller the one being converted from

// MethodBeforeToORM called before default ToORM code
type MethodWithBeforeToORM interface {
	BeforeToORM(context.Context, *MethodORM) error
}

// MethodAfterToORM called after default ToORM code
type MethodWithAfterToORM interface {
	AfterToORM(context.Context, *MethodORM) error
}

// MethodBeforeToPB called before default ToPB code
type MethodWithBeforeToPB interface {
	BeforeToPB(context.Context, *Method) error
}

// MethodAfterToPB called after default ToPB code
type MethodWithAfterToPB interface {
	AfterToPB(context.Context, *Method) error
}

type ReceiptORM struct {
	Datetime   string
	EmployeeId uint32
	Id         uint32
	LocationId uint32
	MethodId   uint32
}

// TableName overrides the default tablename generated by GORM
func (ReceiptORM) TableName() string {
	return "receipts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Receipt) ToORM(ctx context.Context) (ReceiptORM, error) {
	to := ReceiptORM{}
	var err error
	if prehook, ok := interface{}(m).(ReceiptWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EmployeeId = m.EmployeeId
	to.LocationId = m.LocationId
	to.MethodId = m.MethodId
	to.Datetime = m.Datetime
	if posthook, ok := interface{}(m).(ReceiptWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ReceiptORM) ToPB(ctx context.Context) (Receipt, error) {
	to := Receipt{}
	var err error
	if prehook, ok := interface{}(m).(ReceiptWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.EmployeeId = m.EmployeeId
	to.LocationId = m.LocationId
	to.MethodId = m.MethodId
	to.Datetime = m.Datetime
	if posthook, ok := interface{}(m).(ReceiptWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Receipt the arg will be the target, the caller the one being converted from

// ReceiptBeforeToORM called before default ToORM code
type ReceiptWithBeforeToORM interface {
	BeforeToORM(context.Context, *ReceiptORM) error
}

// ReceiptAfterToORM called after default ToORM code
type ReceiptWithAfterToORM interface {
	AfterToORM(context.Context, *ReceiptORM) error
}

// ReceiptBeforeToPB called before default ToPB code
type ReceiptWithBeforeToPB interface {
	BeforeToPB(context.Context, *Receipt) error
}

// ReceiptAfterToPB called after default ToPB code
type ReceiptWithAfterToPB interface {
	AfterToPB(context.Context, *Receipt) error
}

type PurchaseORM struct {
	Amount    float32
	Id        uint32
	Price     float32
	PriceId   uint32
	ReceiptId uint32
	Result    float32
}

// TableName overrides the default tablename generated by GORM
func (PurchaseORM) TableName() string {
	return "purchases"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Purchase) ToORM(ctx context.Context) (PurchaseORM, error) {
	to := PurchaseORM{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ReceiptId = m.ReceiptId
	to.PriceId = m.PriceId
	to.Amount = m.Amount
	to.Price = m.Price
	to.Result = m.Result
	if posthook, ok := interface{}(m).(PurchaseWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PurchaseORM) ToPB(ctx context.Context) (Purchase, error) {
	to := Purchase{}
	var err error
	if prehook, ok := interface{}(m).(PurchaseWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.ReceiptId = m.ReceiptId
	to.PriceId = m.PriceId
	to.Amount = m.Amount
	to.Price = m.Price
	to.Result = m.Result
	if posthook, ok := interface{}(m).(PurchaseWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Purchase the arg will be the target, the caller the one being converted from

// PurchaseBeforeToORM called before default ToORM code
type PurchaseWithBeforeToORM interface {
	BeforeToORM(context.Context, *PurchaseORM) error
}

// PurchaseAfterToORM called after default ToORM code
type PurchaseWithAfterToORM interface {
	AfterToORM(context.Context, *PurchaseORM) error
}

// PurchaseBeforeToPB called before default ToPB code
type PurchaseWithBeforeToPB interface {
	BeforeToPB(context.Context, *Purchase) error
}

// PurchaseAfterToPB called after default ToPB code
type PurchaseWithAfterToPB interface {
	AfterToPB(context.Context, *Purchase) error
}

// DefaultCreateCurrency executes a basic gorm create call
func DefaultCreateCurrency(ctx context.Context, in *Currency, db *gorm1.DB) (*Currency, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadCurrency executes a basic gorm read call
func DefaultReadCurrency(ctx context.Context, in *Currency, db *gorm1.DB) (*Currency, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &CurrencyORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := CurrencyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(CurrencyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type CurrencyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteCurrency(ctx context.Context, in *Currency, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type CurrencyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteCurrencySet(ctx context.Context, in []*Currency, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&CurrencyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&CurrencyORM{})).(CurrencyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type CurrencyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Currency, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Currency, *gorm1.DB) error
}

// DefaultStrictUpdateCurrency clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateCurrency(ctx context.Context, in *Currency, db *gorm1.DB) (*Currency, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateCurrency")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &CurrencyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type CurrencyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchCurrency executes a basic gorm update call with patch behavior
func DefaultPatchCurrency(ctx context.Context, in *Currency, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Currency, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Currency
	var err error
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadCurrency(ctx, &Currency{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskCurrency(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(CurrencyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateCurrency(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(CurrencyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type CurrencyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Currency, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Currency, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Currency, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Currency, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskCurrency patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskCurrency(ctx context.Context, patchee *Currency, patcher *Currency, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Currency, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Code" {
			patchee.Code = patcher.Code
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListCurrency executes a gorm list call
func DefaultListCurrency(ctx context.Context, db *gorm1.DB) ([]*Currency, error) {
	in := Currency{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &CurrencyORM{}, &Currency{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []CurrencyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(CurrencyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Currency{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type CurrencyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type CurrencyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]CurrencyORM) error
}

// DefaultCreateRateOfExchange executes a basic gorm create call
func DefaultCreateRateOfExchange(ctx context.Context, in *RateOfExchange, db *gorm1.DB) (*RateOfExchange, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type RateOfExchangeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadRateOfExchange executes a basic gorm read call
func DefaultReadRateOfExchange(ctx context.Context, in *RateOfExchange, db *gorm1.DB) (*RateOfExchange, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &RateOfExchangeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := RateOfExchangeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(RateOfExchangeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type RateOfExchangeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteRateOfExchange(ctx context.Context, in *RateOfExchange, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&RateOfExchangeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type RateOfExchangeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteRateOfExchangeSet(ctx context.Context, in []*RateOfExchange, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&RateOfExchangeORM{})).(RateOfExchangeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&RateOfExchangeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&RateOfExchangeORM{})).(RateOfExchangeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type RateOfExchangeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*RateOfExchange, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*RateOfExchange, *gorm1.DB) error
}

// DefaultStrictUpdateRateOfExchange clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateRateOfExchange(ctx context.Context, in *RateOfExchange, db *gorm1.DB) (*RateOfExchange, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateRateOfExchange")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &RateOfExchangeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type RateOfExchangeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchRateOfExchange executes a basic gorm update call with patch behavior
func DefaultPatchRateOfExchange(ctx context.Context, in *RateOfExchange, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*RateOfExchange, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj RateOfExchange
	var err error
	if hook, ok := interface{}(&pbObj).(RateOfExchangeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadRateOfExchange(ctx, &RateOfExchange{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(RateOfExchangeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskRateOfExchange(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(RateOfExchangeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateRateOfExchange(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(RateOfExchangeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type RateOfExchangeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *RateOfExchange, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *RateOfExchange, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *RateOfExchange, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *RateOfExchange, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskRateOfExchange patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskRateOfExchange(ctx context.Context, patchee *RateOfExchange, patcher *RateOfExchange, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*RateOfExchange, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FromId" {
			patchee.FromId = patcher.FromId
			continue
		}
		if f == prefix+"ToId" {
			patchee.ToId = patcher.ToId
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListRateOfExchange executes a gorm list call
func DefaultListRateOfExchange(ctx context.Context, db *gorm1.DB) ([]*RateOfExchange, error) {
	in := RateOfExchange{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &RateOfExchangeORM{}, &RateOfExchange{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []RateOfExchangeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(RateOfExchangeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*RateOfExchange{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type RateOfExchangeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type RateOfExchangeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]RateOfExchangeORM) error
}

// DefaultCreateLocation executes a basic gorm create call
func DefaultCreateLocation(ctx context.Context, in *Location, db *gorm1.DB) (*Location, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LocationORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadLocation executes a basic gorm read call
func DefaultReadLocation(ctx context.Context, in *Location, db *gorm1.DB) (*Location, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &LocationORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LocationORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LocationORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LocationORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteLocation(ctx context.Context, in *Location, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LocationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LocationORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteLocationSet(ctx context.Context, in []*Location, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LocationORM{})).(LocationORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LocationORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LocationORM{})).(LocationORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LocationORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Location, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Location, *gorm1.DB) error
}

// DefaultStrictUpdateLocation clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLocation(ctx context.Context, in *Location, db *gorm1.DB) (*Location, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLocation")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LocationORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LocationORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchLocation executes a basic gorm update call with patch behavior
func DefaultPatchLocation(ctx context.Context, in *Location, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Location, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Location
	var err error
	if hook, ok := interface{}(&pbObj).(LocationWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLocation(ctx, &Location{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LocationWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLocation(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LocationWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLocation(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LocationWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LocationWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Location, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LocationWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Location, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LocationWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Location, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type LocationWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Location, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskLocation patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLocation(ctx context.Context, patchee *Location, patcher *Location, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Location, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
		if f == prefix+"CurrencyId" {
			patchee.CurrencyId = patcher.CurrencyId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLocation executes a gorm list call
func DefaultListLocation(ctx context.Context, db *gorm1.DB) ([]*Location, error) {
	in := Location{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &LocationORM{}, &Location{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LocationORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LocationORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Location{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LocationORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type LocationORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]LocationORM) error
}

// DefaultCreateProduct executes a basic gorm create call
func DefaultCreateProduct(ctx context.Context, in *Product, db *gorm1.DB) (*Product, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ProductORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadProduct executes a basic gorm read call
func DefaultReadProduct(ctx context.Context, in *Product, db *gorm1.DB) (*Product, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ProductORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ProductORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ProductORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ProductORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteProduct(ctx context.Context, in *Product, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ProductORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ProductORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteProductSet(ctx context.Context, in []*Product, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ProductORM{})).(ProductORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ProductORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ProductORM{})).(ProductORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ProductORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Product, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Product, *gorm1.DB) error
}

// DefaultStrictUpdateProduct clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateProduct(ctx context.Context, in *Product, db *gorm1.DB) (*Product, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateProduct")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ProductORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ProductORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchProduct executes a basic gorm update call with patch behavior
func DefaultPatchProduct(ctx context.Context, in *Product, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Product, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Product
	var err error
	if hook, ok := interface{}(&pbObj).(ProductWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadProduct(ctx, &Product{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ProductWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskProduct(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ProductWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateProduct(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ProductWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ProductWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Product, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProductWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Product, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProductWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Product, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ProductWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Product, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskProduct patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskProduct(ctx context.Context, patchee *Product, patcher *Product, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Product, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListProduct executes a gorm list call
func DefaultListProduct(ctx context.Context, db *gorm1.DB) ([]*Product, error) {
	in := Product{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ProductORM{}, &Product{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ProductORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ProductORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Product{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ProductORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ProductORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ProductORM) error
}

// DefaultCreatePrice executes a basic gorm create call
func DefaultCreatePrice(ctx context.Context, in *Price, db *gorm1.DB) (*Price, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PriceORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPrice executes a basic gorm read call
func DefaultReadPrice(ctx context.Context, in *Price, db *gorm1.DB) (*Price, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PriceORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PriceORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PriceORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PriceORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePrice(ctx context.Context, in *Price, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PriceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PriceORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePriceSet(ctx context.Context, in []*Price, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PriceORM{})).(PriceORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PriceORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PriceORM{})).(PriceORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PriceORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Price, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Price, *gorm1.DB) error
}

// DefaultStrictUpdatePrice clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePrice(ctx context.Context, in *Price, db *gorm1.DB) (*Price, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePrice")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PriceORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PriceORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPrice executes a basic gorm update call with patch behavior
func DefaultPatchPrice(ctx context.Context, in *Price, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Price, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Price
	var err error
	if hook, ok := interface{}(&pbObj).(PriceWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPrice(ctx, &Price{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PriceWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPrice(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PriceWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePrice(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PriceWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PriceWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Price, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PriceWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Price, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PriceWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Price, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PriceWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Price, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskPrice patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPrice(ctx context.Context, patchee *Price, patcher *Price, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Price, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ProductId" {
			patchee.ProductId = patcher.ProductId
			continue
		}
		if f == prefix+"LocationId" {
			patchee.LocationId = patcher.LocationId
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPrice executes a gorm list call
func DefaultListPrice(ctx context.Context, db *gorm1.DB) ([]*Price, error) {
	in := Price{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PriceORM{}, &Price{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PriceORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PriceORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Price{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PriceORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PriceORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PriceORM) error
}

// DefaultCreatePosition executes a basic gorm create call
func DefaultCreatePosition(ctx context.Context, in *Position, db *gorm1.DB) (*Position, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PositionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPosition executes a basic gorm read call
func DefaultReadPosition(ctx context.Context, in *Position, db *gorm1.DB) (*Position, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PositionORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PositionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PositionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PositionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePosition(ctx context.Context, in *Position, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PositionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PositionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePositionSet(ctx context.Context, in []*Position, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PositionORM{})).(PositionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PositionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PositionORM{})).(PositionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PositionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Position, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Position, *gorm1.DB) error
}

// DefaultStrictUpdatePosition clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePosition(ctx context.Context, in *Position, db *gorm1.DB) (*Position, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePosition")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PositionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PositionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPosition executes a basic gorm update call with patch behavior
func DefaultPatchPosition(ctx context.Context, in *Position, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Position, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Position
	var err error
	if hook, ok := interface{}(&pbObj).(PositionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPosition(ctx, &Position{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PositionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPosition(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PositionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePosition(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PositionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PositionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Position, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PositionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Position, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PositionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Position, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PositionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Position, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskPosition patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPosition(ctx context.Context, patchee *Position, patcher *Position, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Position, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
		if f == prefix+"Description" {
			patchee.Description = patcher.Description
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPosition executes a gorm list call
func DefaultListPosition(ctx context.Context, db *gorm1.DB) ([]*Position, error) {
	in := Position{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PositionORM{}, &Position{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PositionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PositionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Position{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PositionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PositionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PositionORM) error
}

// DefaultCreateEmployee executes a basic gorm create call
func DefaultCreateEmployee(ctx context.Context, in *Employee, db *gorm1.DB) (*Employee, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadEmployee executes a basic gorm read call
func DefaultReadEmployee(ctx context.Context, in *Employee, db *gorm1.DB) (*Employee, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &EmployeeORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := EmployeeORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(EmployeeORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type EmployeeORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmployee(ctx context.Context, in *Employee, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&EmployeeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type EmployeeORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteEmployeeSet(ctx context.Context, in []*Employee, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&EmployeeORM{})).(EmployeeORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&EmployeeORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&EmployeeORM{})).(EmployeeORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type EmployeeORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Employee, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Employee, *gorm1.DB) error
}

// DefaultStrictUpdateEmployee clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateEmployee(ctx context.Context, in *Employee, db *gorm1.DB) (*Employee, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateEmployee")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &EmployeeORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type EmployeeORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchEmployee executes a basic gorm update call with patch behavior
func DefaultPatchEmployee(ctx context.Context, in *Employee, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Employee, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Employee
	var err error
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadEmployee(ctx, &Employee{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskEmployee(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(EmployeeWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateEmployee(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(EmployeeWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type EmployeeWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Employee, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Employee, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Employee, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Employee, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskEmployee patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskEmployee(ctx context.Context, patchee *Employee, patcher *Employee, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Employee, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"PositionId" {
			patchee.PositionId = patcher.PositionId
			continue
		}
		if f == prefix+"LocationId" {
			patchee.LocationId = patcher.LocationId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListEmployee executes a gorm list call
func DefaultListEmployee(ctx context.Context, db *gorm1.DB) ([]*Employee, error) {
	in := Employee{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &EmployeeORM{}, &Employee{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []EmployeeORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(EmployeeORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Employee{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type EmployeeORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type EmployeeORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]EmployeeORM) error
}

// DefaultCreateMethod executes a basic gorm create call
func DefaultCreateMethod(ctx context.Context, in *Method, db *gorm1.DB) (*Method, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MethodORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadMethod executes a basic gorm read call
func DefaultReadMethod(ctx context.Context, in *Method, db *gorm1.DB) (*Method, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &MethodORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MethodORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MethodORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MethodORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteMethod(ctx context.Context, in *Method, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MethodORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MethodORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteMethodSet(ctx context.Context, in []*Method, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MethodORM{})).(MethodORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MethodORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MethodORM{})).(MethodORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MethodORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Method, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Method, *gorm1.DB) error
}

// DefaultStrictUpdateMethod clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMethod(ctx context.Context, in *Method, db *gorm1.DB) (*Method, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMethod")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MethodORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MethodORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchMethod executes a basic gorm update call with patch behavior
func DefaultPatchMethod(ctx context.Context, in *Method, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Method, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Method
	var err error
	if hook, ok := interface{}(&pbObj).(MethodWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMethod(ctx, &Method{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MethodWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMethod(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MethodWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMethod(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MethodWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MethodWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Method, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MethodWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Method, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MethodWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Method, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type MethodWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Method, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskMethod patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMethod(ctx context.Context, patchee *Method, patcher *Method, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Method, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Name" {
			patchee.Name = patcher.Name
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMethod executes a gorm list call
func DefaultListMethod(ctx context.Context, db *gorm1.DB) ([]*Method, error) {
	in := Method{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &MethodORM{}, &Method{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MethodORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MethodORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Method{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MethodORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type MethodORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]MethodORM) error
}

// DefaultCreateReceipt executes a basic gorm create call
func DefaultCreateReceipt(ctx context.Context, in *Receipt, db *gorm1.DB) (*Receipt, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ReceiptORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadReceipt executes a basic gorm read call
func DefaultReadReceipt(ctx context.Context, in *Receipt, db *gorm1.DB) (*Receipt, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &ReceiptORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ReceiptORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ReceiptORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ReceiptORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeleteReceipt(ctx context.Context, in *Receipt, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ReceiptORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ReceiptORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeleteReceiptSet(ctx context.Context, in []*Receipt, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ReceiptORM{})).(ReceiptORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ReceiptORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ReceiptORM{})).(ReceiptORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ReceiptORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Receipt, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Receipt, *gorm1.DB) error
}

// DefaultStrictUpdateReceipt clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateReceipt(ctx context.Context, in *Receipt, db *gorm1.DB) (*Receipt, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateReceipt")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ReceiptORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ReceiptORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchReceipt executes a basic gorm update call with patch behavior
func DefaultPatchReceipt(ctx context.Context, in *Receipt, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Receipt, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Receipt
	var err error
	if hook, ok := interface{}(&pbObj).(ReceiptWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadReceipt(ctx, &Receipt{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ReceiptWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskReceipt(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ReceiptWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateReceipt(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ReceiptWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ReceiptWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Receipt, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Receipt, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Receipt, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Receipt, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskReceipt patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskReceipt(ctx context.Context, patchee *Receipt, patcher *Receipt, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Receipt, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"EmployeeId" {
			patchee.EmployeeId = patcher.EmployeeId
			continue
		}
		if f == prefix+"LocationId" {
			patchee.LocationId = patcher.LocationId
			continue
		}
		if f == prefix+"MethodId" {
			patchee.MethodId = patcher.MethodId
			continue
		}
		if f == prefix+"Datetime" {
			patchee.Datetime = patcher.Datetime
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListReceipt executes a gorm list call
func DefaultListReceipt(ctx context.Context, db *gorm1.DB) ([]*Receipt, error) {
	in := Receipt{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &ReceiptORM{}, &Receipt{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ReceiptORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ReceiptORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Receipt{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ReceiptORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type ReceiptORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]ReceiptORM) error
}

// DefaultCreatePurchase executes a basic gorm create call
func DefaultCreatePurchase(ctx context.Context, in *Purchase, db *gorm1.DB) (*Purchase, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm1.DB) error
}

// DefaultReadPurchase executes a basic gorm read call
func DefaultReadPurchase(ctx context.Context, in *Purchase, db *gorm1.DB) (*Purchase, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm2.ApplyFieldSelection(ctx, db, nil, &PurchaseORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PurchaseORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PurchaseORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PurchaseORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm1.DB) error
}

func DefaultDeletePurchase(ctx context.Context, in *Purchase, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors1.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PurchaseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PurchaseORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm1.DB) error
}

func DefaultDeletePurchaseSet(ctx context.Context, in []*Purchase, db *gorm1.DB) error {
	if in == nil {
		return errors1.NilArgumentError
	}
	var err error
	keys := []uint32{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors1.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PurchaseORM{})).(PurchaseORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PurchaseORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PurchaseORM{})).(PurchaseORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PurchaseORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Purchase, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Purchase, *gorm1.DB) error
}

// DefaultStrictUpdatePurchase clears first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePurchase(ctx context.Context, in *Purchase, db *gorm1.DB) (*Purchase, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePurchase")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PurchaseORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PurchaseORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm1.DB) error
}

// DefaultPatchPurchase executes a basic gorm update call with patch behavior
func DefaultPatchPurchase(ctx context.Context, in *Purchase, updateMask *field_mask1.FieldMask, db *gorm1.DB) (*Purchase, error) {
	if in == nil {
		return nil, errors1.NilArgumentError
	}
	var pbObj Purchase
	var err error
	if hook, ok := interface{}(&pbObj).(PurchaseWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPurchase(ctx, &Purchase{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PurchaseWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPurchase(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PurchaseWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePurchase(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PurchaseWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PurchaseWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Purchase, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Purchase, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Purchase, *field_mask1.FieldMask, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Purchase, *field_mask1.FieldMask, *gorm1.DB) error
}

// DefaultApplyFieldMaskPurchase patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPurchase(ctx context.Context, patchee *Purchase, patcher *Purchase, updateMask *field_mask1.FieldMask, prefix string, db *gorm1.DB) (*Purchase, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors1.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"ReceiptId" {
			patchee.ReceiptId = patcher.ReceiptId
			continue
		}
		if f == prefix+"PriceId" {
			patchee.PriceId = patcher.PriceId
			continue
		}
		if f == prefix+"Amount" {
			patchee.Amount = patcher.Amount
			continue
		}
		if f == prefix+"Price" {
			patchee.Price = patcher.Price
			continue
		}
		if f == prefix+"Result" {
			patchee.Result = patcher.Result
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPurchase executes a gorm list call
func DefaultListPurchase(ctx context.Context, db *gorm1.DB) ([]*Purchase, error) {
	in := Purchase{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm2.ApplyCollectionOperators(ctx, db, &PurchaseORM{}, &Purchase{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PurchaseORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PurchaseORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Purchase{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PurchaseORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm1.DB) (*gorm1.DB, error)
}
type PurchaseORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm1.DB, *[]PurchaseORM) error
}
